# app.py - Multi-Agent Game Generation System
import streamlit as st
import google.generativeai as genai
import os
from pathlib import Path
import json
import time
from dotenv import load_dotenv
import re
import shutil # For potentially cleaning workspace
from typing import TypedDict, List, Dict, Optional, Sequence
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver # For potential future state saving

# --- Configuration ---
st.set_page_config(layout="wide", page_title="AI Gener√°tor Hier")
load_dotenv()

# --- Constants ---
WORKSPACE_DIR = Path("workspace")
WORKSPACE_DIR.mkdir(exist_ok=True)
MAX_GAMES = 16 # Target number of games

# --- Gemini API Configuration ---
try:
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        st.error("üî¥ Google API kƒæ√∫ƒç nen√°jden√Ω. Pros√≠m, uistite sa, ≈æe GOOGLE_API_KEY je nastaven√Ω vo va≈°om .env s√∫bore.")
        st.stop()
    genai.configure(api_key=api_key)
    model_name = os.getenv("GEMINI_MODEL", "gemini-1.5-flash-latest") # Using a potentially faster model
    model = genai.GenerativeModel(model_name)
    st.sidebar.caption(f"Pou≈æ√≠van√Ω model: `{model_name}`")
except Exception as e:
    st.error(f"üî¥ Nepodarilo sa nakonfigurova≈• Gemini alebo naƒç√≠ta≈• model '{model_name}' pomocou .env: {e}")
    st.stop()

# --- LangGraph State Definition ---
class AgentState(TypedDict):
    theme: str
    game_concepts: Optional[List[str]]
    game_plan: Optional[List[Dict[str, str]]] # List of {"concept": "...", "instruction": "..."}
    current_game_index: int
    worker_output: Optional[List[Dict[str, str]]] # Output from the worker agent for the current game
    saved_games: List[Dict[str, str]] # List of {"name": "...", "folder": "..."}
    log_messages: List[str]
    error: Optional[str]

# --- Helper Functions ---
def sanitize_foldername(name: str) -> str:
    """Creates a safe folder name from a game concept."""
    name = re.sub(r'[^\w\s-]', '', name).strip().lower()
    name = re.sub(r'[-\s]+', '_', name)
    return name if name else "untitled_game"

def save_game_files(game_name: str, game_index: int, files_data: List[Dict[str, str]]) -> Optional[str]:
    """Saves generated files to a dedicated game folder."""
    folder_name = f"{sanitize_foldername(game_name)}_{game_index:02d}"
    game_dir = WORKSPACE_DIR / folder_name
    try:
        game_dir.mkdir(parents=True, exist_ok=True)
        for file_info in files_data:
            filename = file_info.get("filename")
            content = file_info.get("content")
            if filename and content is not None:
                # Basic security check
                if ".." in filename or filename.startswith(("/", "\\")):
                    st.warning(f"‚ö†Ô∏è Preskoƒçen√Ω nebezpeƒçn√Ω n√°zov s√∫boru v hre {game_name}: {filename}")
                    continue
                filepath = game_dir / filename
                filepath.parent.mkdir(parents=True, exist_ok=True) # Ensure subdirs within game folder are created
                with open(filepath, "w", encoding="utf-8") as f:
                    f.write(content)
            else:
                 st.warning(f"‚ö†Ô∏è Ch√Ωbaj√∫ce 'filename' alebo 'content' v d√°tach pre hru {game_name}: {file_info}")
        return str(game_dir) # Return the path to the created directory
    except Exception as e:
        st.error(f"üî¥ Chyba pri ukladan√≠ s√∫borov pre hru '{game_name}' do '{folder_name}': {e}")
        return None

def call_llm(prompt: str, is_json_output: bool = True) -> str:
    """ Helper function to call the LLM and handle potential errors. """
    try:
        # Simple retry mechanism
        for attempt in range(2):
            try:
                response = model.generate_content(prompt)
                # Basic validation if JSON is expected
                if is_json_output:
                    cleaned_response = response.text.strip()
                    if cleaned_response.startswith("```json"):
                        cleaned_response = cleaned_response[7:-3].strip()
                    elif cleaned_response.startswith("```"):
                         cleaned_response = cleaned_response[3:-3].strip()
                    # Try parsing to catch invalid JSON early
                    json.loads(cleaned_response)
                    return cleaned_response
                else:
                    return response.text
            except Exception as inner_e:
                if "429" in str(inner_e) and attempt == 0:
                    st.warning("‚è≥ Limit API prekroƒçen√Ω, ƒçak√°m 5 sek√∫nd pred opakovan√≠m...")
                    time.sleep(5)
                    continue # Retry
                elif is_json_output and isinstance(inner_e, json.JSONDecodeError):
                     st.warning(f"‚ö†Ô∏è LLM vr√°tilo neplatn√Ω JSON, sk√∫≈°am znova... Chyba: {inner_e}")
                     if attempt == 0: continue # Retry on first JSON error
                     else: raise # Raise error on second JSON failure
                else:
                    raise # Re-raise other errors or errors on second attempt
        # If loop finishes without returning/raising (e.g., due to retries)
        raise Exception("LLM volanie zlyhalo po opakovaniach.")

    except Exception as e:
        st.error(f"üî¥ Volanie LLM zlyhalo: {e}")
        # Return an error structure if JSON was expected
        if is_json_output:
            return json.dumps([{"action": "chat", "content": f"Chyba volania LLM: {e}"}])
        else:
            return f"Chyba volania LLM: {e}"

# --- Agent Node Functions ---

def games_planner_node(state: AgentState) -> AgentState:
    """Generates a list of game concepts based on the theme."""
    theme = state["theme"]
    log_messages = state.get("log_messages", [])
    log_messages.append(f"ü§ñ GAMES_PLANNER: Generujem {MAX_GAMES} konceptov hier pre t√©mu '{theme}'...")
    st.session_state.log_messages = log_messages # Update UI immediately

    prompt = f"""
    Si kreat√≠vny pl√°novaƒç hier. Vytvor zoznam {MAX_GAMES} jednoduch√Ωch konceptov webov√Ωch hier (HTML, CSS, JS) na t√©mu '{theme}'.
    Zameraj sa na jednoduch√©, dobre zn√°me hern√© mechaniky.
    Odpovedz IBA platn√Ωm JSON poƒæom re≈•azcov obsahuj√∫cim n√°zvy hern√Ωch konceptov.

    Pr√≠klad pre t√©mu 'vesm√≠r':
    ["H√°daj plan√©tu", "Vesm√≠rny kliker", "Pexeso s kozmick√Ωmi loƒèami", "Kv√≠z o s√∫hvezdiach", ...]
    """
    try:
        response_text = call_llm(prompt, is_json_output=True)
        game_concepts = json.loads(response_text)
        if not isinstance(game_concepts, list) or not all(isinstance(item, str) for item in game_concepts):
            raise ValueError("LLM nevr√°tilo platn√Ω zoznam n√°zvov hier.")
        log_messages.append(f"‚úÖ GAMES_PLANNER: Koncepty hier vygenerovan√© ({len(game_concepts)} hier).")
        return {**state, "game_concepts": game_concepts[:MAX_GAMES], "log_messages": log_messages, "error": None}
    except Exception as e:
        error_msg = f"üî¥ GAMES_PLANNER zlyhal: {e}"
        log_messages.append(error_msg)
        return {**state, "log_messages": log_messages, "error": error_msg}

def profesor_planner_node(state: AgentState) -> AgentState:
    """Refines the game concepts with aesthetic instructions."""
    game_concepts = state.get("game_concepts")
    log_messages = state.get("log_messages", [])
    if not game_concepts:
        error_msg = "üî¥ PROFESOR_PLANNER: Ch√Ωbaj√∫ hern√© koncepty."
        log_messages.append(error_msg)
        return {**state, "log_messages": log_messages, "error": error_msg}

    log_messages.append("üßë‚Äçüè´ PROFESOR_PLANNER: Prid√°vam in≈°trukcie pre vizu√°lnu str√°nku ku ka≈æd√©mu konceptu...")
    st.session_state.log_messages = log_messages

    game_plan = []
    for concept in game_concepts:
        instruction = (
            f"Vytvor jednoduch√∫ webov√∫ hru '{concept}'. "
            f"Prioritou je vytvori≈• **vizu√°lne kr√°sne a p√∫tav√© pou≈æ√≠vateƒæsk√© rozhranie (UI)** pomocou modern√©ho CSS. "
            f"Zahr≈à relevantn√∫ **grafiku** (zv√°≈æ SVG, CSS art alebo jednoduch√© obr√°zky, ak je to vhodn√©) a p√∫tav√© **CSS anim√°cie**. "
            f"Vzhƒæad a dojem s√∫ d√¥le≈æitej≈°ie ako zlo≈æit√° hern√° logika. Hra by mala by≈• hrateƒæn√°, ale jednoduch√°."
        )
        game_plan.append({"concept": concept, "instruction": instruction})

    log_messages.append("‚úÖ PROFESOR_PLANNER: Hern√Ω pl√°n s in≈°trukciami vytvoren√Ω.")
    return {**state, "game_plan": game_plan, "log_messages": log_messages, "error": None}

def worker_node(state: AgentState) -> AgentState:
    """Generates the files for the current game based on the plan."""
    game_plan = state.get("game_plan")
    current_index = state.get("current_game_index", 0)
    log_messages = state.get("log_messages", [])

    if not game_plan or current_index >= len(game_plan):
        error_msg = f"üî¥ WORKER: Neplatn√Ω hern√Ω pl√°n alebo index ({current_index})."
        log_messages.append(error_msg)
        return {**state, "log_messages": log_messages, "error": error_msg}

    current_game = game_plan[current_index]
    concept = current_game["concept"]
    instruction = current_game["instruction"]
    theme = state["theme"]

    log_messages.append(f"üë∑ WORKER: Zaƒç√≠nam generova≈• hru {current_index + 1}/{len(game_plan)}: '{concept}'...")
    st.session_state.log_messages = log_messages

    prompt = f"""
    Si expert na v√Ωvoj webov√Ωch hier (HTML, CSS, JavaScript). Tvojou √∫lohou je vytvori≈• s√∫bory pre jednoduch√∫ webov√∫ hru.

    T√©ma: '{theme}'
    Koncept hry: '{concept}'
    ≈†pecifick√© in≈°trukcie: '{instruction}'

    Po≈æiadavky na v√Ωstup:
    1. Vygeneruj potrebn√© s√∫bory (typicky index.html, style.css, script.js).
    2. Zameraj sa na vizu√°lnu str√°nku podƒæa in≈°trukci√≠ (kr√°sne UI, grafika, anim√°cie).
    3. Udr≈æuj k√≥d jednoduch√Ω a funkƒçn√Ω pre dan√Ω koncept.
    4. V≈°etky s√∫bory musia by≈• samostatn√© (≈æiadne extern√© z√°vislosti okrem be≈æn√Ωch prehliadaƒçov√Ωch API).
    5. Odpovedz IBA platn√Ωm JSON poƒæom objektov, kde ka≈æd√Ω objekt reprezentuje jeden s√∫bor.
       Form√°t objektu s√∫boru: {{"filename": "nazov_suboru.ext", "content": "obsah s√∫boru ako re≈•azec..."}}
    6. D√¥sledne dodr≈æuj JSON form√°tovanie: dvojit√© √∫vodzovky pre kƒæ√∫ƒçe a re≈•azce, spr√°vne escapovanie ≈°peci√°lnych znakov (\\n, \\", atƒè.) v obsahu s√∫boru.

    Pr√≠klad JSON v√Ωstupu:
    [
      {{"filename": "index.html", "content": "<!DOCTYPE html>..."}},
      {{"filename": "style.css", "content": "body {{ ... }}"}},
      {{"filename": "script.js", "content": "console.log('Hello');"}}
    ]
    """

    try:
        response_text = call_llm(prompt, is_json_output=True)
        files_data = json.loads(response_text)
        if not isinstance(files_data, list) or not all(isinstance(item, dict) and "filename" in item and "content" in item for item in files_data):
             raise ValueError("LLM nevr√°tilo platn√Ω zoznam s√∫borov v JSON form√°te.")

        log_messages.append(f"‚úÖ WORKER: S√∫bory pre '{concept}' vygenerovan√©.")
        return {**state, "worker_output": files_data, "log_messages": log_messages, "error": None}
    except Exception as e:
        error_msg = f"üî¥ WORKER zlyhal pri generovan√≠ '{concept}': {e}"
        log_messages.append(error_msg)
        # Still proceed to next game, but log the error
        return {**state, "worker_output": None, "log_messages": log_messages, "error": error_msg} # Allow graph to continue

def save_and_log_node(state: AgentState) -> AgentState:
    """Saves the generated files and updates the list of saved games."""
    worker_output = state.get("worker_output")
    game_plan = state.get("game_plan")
    current_index = state.get("current_game_index", 0)
    saved_games = state.get("saved_games", [])
    log_messages = state.get("log_messages", [])

    if worker_output and game_plan and current_index < len(game_plan):
        concept = game_plan[current_index]["concept"]
        log_messages.append(f"üíæ Uklad√°m s√∫bory pre hru '{concept}'...")
        st.session_state.log_messages = log_messages

        game_dir = save_game_files(concept, current_index + 1, worker_output)

        if game_dir:
            saved_games.append({"name": concept, "folder": game_dir})
            log_messages.append(f"‚úÖ Hra '{concept}' ulo≈æen√° do '{Path(game_dir).name}'.")
        else:
            # Error logged in save_game_files
            log_messages.append(f"‚ùå Nepodarilo sa ulo≈æi≈• s√∫bory pre '{concept}'.")

    elif not worker_output and state.get("error"):
         # Error already logged by worker
         pass # Just move to the next game
    else:
        log_messages.append(f"ü§î Preskakujem ukladanie pre hru index {current_index} (≈æiadny v√Ωstup alebo neplatn√Ω stav).")


    # Increment index for the next iteration
    next_index = current_index + 1
    return {**state, "saved_games": saved_games, "current_game_index": next_index, "log_messages": log_messages, "worker_output": None} # Clear worker output

# --- Conditional Edge ---
def should_continue(state: AgentState) -> str:
    """Determines whether to continue the loop or end."""
    current_index = state.get("current_game_index", 0)
    game_plan = state.get("game_plan", [])
    error = state.get("error")

    # Stop if major error occurred before worker loop
    if not game_plan and error:
        return "end_process"

    if current_index >= len(game_plan) or current_index >= MAX_GAMES:
        return "end_process"
    else:
        return "continue_worker"

# --- Build the Graph ---
graph_builder = StateGraph(AgentState)

graph_builder.add_node("games_planner", games_planner_node)
graph_builder.add_node("profesor_planner", profesor_planner_node)
graph_builder.add_node("worker", worker_node)
graph_builder.add_node("save_and_log", save_and_log_node)

graph_builder.set_entry_point("games_planner")
graph_builder.add_edge("games_planner", "profesor_planner")

# Conditional loop for worker
graph_builder.add_conditional_edges(
    "profesor_planner",
    should_continue,
    {
        "continue_worker": "worker", # Start worker loop if plan exists
        "end_process": END
    }
)
graph_builder.add_conditional_edges(
    "save_and_log", # After saving/logging, check if loop should continue
    should_continue,
    {
        "continue_worker": "worker", # Go back to worker for next game
        "end_process": END
    }
)
graph_builder.add_edge("worker", "save_and_log")

# Compile the graph
# memory = MemorySaver() # Optional: For resuming runs later
app_graph = graph_builder.compile() # checkpointer=memory

# --- Streamlit UI ---
st.title("ü§ñ AI Gener√°tor Hier (Multi-Agent)")
st.markdown("Zadajte t√©mu a AI agenti vygeneruj√∫ s√©riu jednoduch√Ωch webov√Ωch hier.")

# --- Input Area ---
theme_input = st.text_input("Zadajte t√©mu pre hry:", placeholder="napr. zvierat√°, vesm√≠r, matematika")

if 'log_messages' not in st.session_state:
    st.session_state.log_messages = ["Vitajte! Zadajte t√©mu a stlaƒçte 'Generova≈• Hry'."]
if 'running' not in st.session_state:
    st.session_state.running = False
if 'saved_games_list' not in st.session_state:
     st.session_state.saved_games_list = []

# --- Control Button ---
if st.button("üöÄ Generova≈• 16 Hier", disabled=st.session_state.running or not theme_input):
    # Clear previous run logs and saved games list for UI
    st.session_state.log_messages = [f"üèÅ ≈†tartujem generovanie pre t√©mu: '{theme_input}'"]
    st.session_state.saved_games_list = []
    st.session_state.running = True

    # Clean workspace before starting? Optional.
    # try:
    #     for item in WORKSPACE_DIR.iterdir():
    #         if item.is_dir():
    #             shutil.rmtree(item)
    #         else:
    #             item.unlink()
    #     st.session_state.log_messages.append("üßπ Pracovn√Ω priestor vyƒçisten√Ω.")
    # except Exception as e:
    #     st.session_state.log_messages.append(f"‚ö†Ô∏è Nepodarilo sa vyƒçisti≈• pracovn√Ω priestor: {e}")

    # Initial state for the graph
    initial_state = AgentState(
        theme=theme_input,
        game_concepts=None,
        game_plan=None,
        current_game_index=0,
        worker_output=None,
        saved_games=[],
        log_messages=st.session_state.log_messages,
        error=None
    )

    # Use st.status for better progress indication
    with st.status("‚öôÔ∏è Sp√∫≈°≈•am agentov...", expanded=True) as status:
        try:
            # Stream the graph execution
            # config = {"configurable": {"thread_id": "game-gen-thread"}} # For memory saver
            final_state = None
            for output in app_graph.stream(initial_state): # Removed config for simplicity
                # output is a dictionary where keys are node names
                # and values are the AgentState after that node ran
                node_name = list(output.keys())[0]
                current_state = list(output.values())[0]

                # Update logs in session state for UI refresh
                st.session_state.log_messages = current_state.get("log_messages", [])
                st.session_state.saved_games_list = current_state.get("saved_games", [])

                # Update status message (optional)
                last_log = st.session_state.log_messages[-1] if st.session_state.log_messages else "Pracujem..."
                status.update(label=f"‚öôÔ∏è {last_log}", state="running")

                # Store the very last state
                final_state = current_state

            # Update status upon completion
            if final_state and final_state.get("error"):
                 status.update(label=f"‚ö†Ô∏è Proces dokonƒçen√Ω s chybami.", state="error")
            else:
                 status.update(label="‚úÖ Proces generovania hier dokonƒçen√Ω!", state="complete")

        except Exception as e:
            st.error(f"üî¥ Neoƒçak√°van√° chyba poƒças behu grafu: {e}")
            status.update(label=f"üí• Kritick√° chyba!", state="error")
            st.session_state.log_messages.append(f"üí• Kritick√° chyba: {e}")
        finally:
            st.session_state.running = False # Allow starting again
            # Rerun to potentially update the showcase if it's on the same page
            # Or rely on user navigating to the showcase page
            st.rerun()


# --- Log Display ---
st.subheader("üìú Priebeh Generovania (Log)")
log_container = st.container(height=300)
with log_container:
    log_text = "\n".join(st.session_state.log_messages)
    st.text(log_text)

# --- Showcase Area (Simple List for now) ---
st.subheader("üéÆ Vygenerovan√© Hry")
if st.session_state.saved_games_list:
    for game_info in st.session_state.saved_games_list:
        game_name = game_info.get("name", "Nezn√°ma hra")
        game_folder = game_info.get("folder", "")
        if game_folder:
            folder_path = Path(game_folder)
            st.markdown(f"- **{game_name}** (v prieƒçinku: `{folder_path.name}`)")
            # Add a link - Note: This link only works reliably if running locally
            # and potentially requires the local server to be running if JS needs it.
            index_file = folder_path / "index.html"
            if index_file.exists():
                 # Simple relative link - might not work well in all scenarios
                 # A better approach might involve the local server if kept
                 st.link_button(f"Otvori≈• {game_name}", f"./{folder_path.relative_to(Path.cwd())}/index.html", help=f"Pok√∫si sa otvori≈• {index_file.name}")

else:
    st.info("Zatiaƒæ neboli vygenerovan√© ≈æiadne hry.")


# --- Footer / Warnings ---
st.sidebar.markdown("---")
st.sidebar.warning("""
    **Obmedzenia prototypu a varovania:**
    - **Generovanie:** M√¥≈æe trva≈• dlho a spotrebova≈• veƒæa API volan√≠.
    - **Kvalita Hier:** Vizu√°lna str√°nka a funkƒçnos≈• z√°vis√≠ od schopnost√≠ LLM.
    - **Bezpeƒçnos≈•:** AI generuje k√≥d. Sp√∫≈°≈•ajte lok√°lne a opatrne.
    - **Stav:** Strat√≠ sa pri obnoven√≠ prehliadaƒça.
""", icon="‚ö†Ô∏è")
